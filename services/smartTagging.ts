/**
 * Smart Tagging Service
 * AI-powered automatic categorization and tagging
 * Uses pattern recognition and heuristics to minimize AI calls
 */

import { ContactInfo } from '../types';

// ==================== TYPES ====================

export interface Tag {
  id: string;
  name: string;
  color: string;
  category: TagCategory;
  autoGenerated: boolean;
  confidence: number;
  createdAt: number;
}

export type TagCategory = 
  | 'industry'
  | 'role'
  | 'priority'
  | 'status'
  | 'source'
  | 'custom';

export interface TagSuggestion {
  tag: string;
  category: TagCategory;
  confidence: number;
  reason: string;
}

export interface AutoTagResult {
  contactId: string;
  addedTags: string[];
  suggestions: TagSuggestion[];
  confidence: number;
}

// ==================== TAG DEFINITIONS ====================

const INDUSTRY_PATTERNS: Record<string, RegExp[]> = {
  'Technology': [/tech|software|IT|digital|cyber|cloud|saas|app|developer|programmer/i],
  'Finance': [/bank|finance|investment|capital|fund|asset|wealth|trading|fintech/i],
  'Healthcare': [/health|medical|pharma|hospital|clinic|doctor|nurse|biotech|wellness/i],
  'Legal': [/law|legal|attorney|lawyer|advocate|solicitor|counsel/i],
  'Real Estate': [/real estate|property|realty|developer|construction|housing/i],
  'Marketing': [/marketing|advertising|media|PR|agency|creative|brand/i],
  'Consulting': [/consult|advisory|strategy|management|mckinsey|bcg|deloitte/i],
  'Manufacturing': [/manufactur|industrial|factory|production|engineering/i],
  'Retail': [/retail|store|shop|e-commerce|consumer|merchandise/i],
  'Education': [/education|university|school|college|academy|training|teach/i],
  'Hospitality': [/hotel|restaurant|hospitality|tourism|travel|resort/i],
  'Logistics': [/logistics|shipping|transport|freight|supply chain|warehouse/i],
};

const ROLE_PATTERNS: Record<string, RegExp[]> = {
  'Executive': [/CEO|CTO|CFO|COO|CMO|CIO|chief|president|founder|owner|director/i],
  'Manager': [/manager|head|lead|supervisor|coordinator|team lead/i],
  'Sales': [/sales|account|business development|BD|revenue/i],
  'Engineering': [/engineer|developer|architect|technical|programmer/i],
  'Design': [/design|UX|UI|creative|artist|visual/i],
  'Operations': [/operations|admin|office|HR|human resources/i],
  'Finance': [/accountant|finance|analyst|controller|auditor/i],
  'Legal': [/legal|counsel|attorney|lawyer|compliance/i],
};

const PRIORITY_KEYWORDS: Record<string, string[]> = {
  'VIP': ['ceo', 'founder', 'president', 'director', 'chief', 'partner', 'principal'],
  'High Priority': ['manager', 'head', 'lead', 'senior', 'head of'],
  'Decision Maker': ['buyer', 'purchasing', 'procurement', 'decision'],
  'Influencer': ['advisor', 'consultant', 'expert', 'specialist'],
};

const COMPANY_SIZE_PATTERNS: Record<string, RegExp[]> = {
  'Enterprise': [/google|microsoft|apple|amazon|meta|ibm|oracle|salesforce|fortune 500/i],
  'Large': [/corp|corporation|inc\.|group|holdings|international/i],
  'Startup': [/startup|venture|early stage|seed|pre-series/i],
  'SMB': [/small business|local|independent|boutique/i],
};

// ==================== TAG STORAGE ====================

const TAGS_STORAGE_KEY = 'kksmartscan_tags';
const CONTACT_TAGS_KEY = 'kksmartscan_contact_tags';

/**
 * Get all tags
 */
export function getAllTags(): Tag[] {
  try {
    return JSON.parse(localStorage.getItem(TAGS_STORAGE_KEY) || '[]');
  } catch {
    return [];
  }
}

/**
 * Save tags
 */
function saveTags(tags: Tag[]): void {
  localStorage.setItem(TAGS_STORAGE_KEY, JSON.stringify(tags));
}

/**
 * Get tags for a contact
 */
export function getContactTags(contactId: string): string[] {
  try {
    const mapping = JSON.parse(localStorage.getItem(CONTACT_TAGS_KEY) || '{}');
    return mapping[contactId] || [];
  } catch {
    return [];
  }
}

/**
 * Save contact tags
 */
export function setContactTags(contactId: string, tags: string[]): void {
  try {
    const mapping = JSON.parse(localStorage.getItem(CONTACT_TAGS_KEY) || '{}');
    mapping[contactId] = tags;
    localStorage.setItem(CONTACT_TAGS_KEY, JSON.stringify(mapping));
  } catch (e) {
    console.error('Failed to save contact tags:', e);
  }
}

/**
 * Add tag to contact
 */
export function addTagToContact(contactId: string, tag: string): void {
  const tags = getContactTags(contactId);
  if (!tags.includes(tag)) {
    tags.push(tag);
    setContactTags(contactId, tags);
  }
}

/**
 * Remove tag from contact
 */
export function removeTagFromContact(contactId: string, tag: string): void {
  const tags = getContactTags(contactId);
  setContactTags(contactId, tags.filter(t => t !== tag));
}

// ==================== AUTO-TAGGING ====================

/**
 * Auto-tag a contact based on its data
 * Uses pattern matching to avoid AI calls
 */
export function autoTagContact(contact: ContactInfo): AutoTagResult {
  const suggestions: TagSuggestion[] = [];
  const addedTags: string[] = [];
  
  // Combine all text fields for analysis
  const textToAnalyze = [
    contact.name,
    contact.firmName,
    contact.jobTitle,
    contact.email,
    contact.industry,
    contact.notes
  ].filter(Boolean).join(' ').toLowerCase();
  
  // Industry detection
  for (const [industry, patterns] of Object.entries(INDUSTRY_PATTERNS)) {
    for (const pattern of patterns) {
      if (pattern.test(textToAnalyze)) {
        suggestions.push({
          tag: industry,
          category: 'industry',
          confidence: 0.85,
          reason: `Detected ${industry} keywords in contact data`
        });
        break;
      }
    }
  }
  
  // Role detection
  for (const [role, patterns] of Object.entries(ROLE_PATTERNS)) {
    for (const pattern of patterns) {
      if (pattern.test(contact.jobTitle || '')) {
        suggestions.push({
          tag: role,
          category: 'role',
          confidence: 0.9,
          reason: `Job title indicates ${role} role`
        });
        break;
      }
    }
  }
  
  // Priority detection
  for (const [priority, keywords] of Object.entries(PRIORITY_KEYWORDS)) {
    const jobLower = (contact.jobTitle || '').toLowerCase();
    if (keywords.some(kw => jobLower.includes(kw))) {
      suggestions.push({
        tag: priority,
        category: 'priority',
        confidence: 0.8,
        reason: `Job title suggests ${priority} status`
      });
      break;
    }
  }
  
  // Company size detection
  for (const [size, patterns] of Object.entries(COMPANY_SIZE_PATTERNS)) {
    for (const pattern of patterns) {
      if (pattern.test(contact.firmName || '')) {
        suggestions.push({
          tag: size,
          category: 'status',
          confidence: 0.7,
          reason: `Company name pattern suggests ${size}`
        });
        break;
      }
    }
  }
  
  // Email domain analysis
  if (contact.email) {
    const domain = contact.email.split('@')[1];
    if (domain) {
      // Corporate email
      if (!domain.match(/gmail|yahoo|hotmail|outlook|icloud/i)) {
        suggestions.push({
          tag: 'Corporate Email',
          category: 'status',
          confidence: 0.95,
          reason: 'Uses corporate email domain'
        });
      }
      
      // Check for known enterprise domains
      if (domain.match(/google|microsoft|amazon|meta|apple/i)) {
        suggestions.push({
          tag: 'Enterprise',
          category: 'status',
          confidence: 0.95,
          reason: 'Works at major tech company'
        });
      }
    }
  }
  
  // Auto-add high-confidence suggestions
  for (const suggestion of suggestions) {
    if (suggestion.confidence >= 0.85) {
      addedTags.push(suggestion.tag);
      addTagToContact(contact.id, suggestion.tag);
    }
  }
  
  // Calculate overall confidence
  const avgConfidence = suggestions.length > 0
    ? suggestions.reduce((sum, s) => sum + s.confidence, 0) / suggestions.length
    : 0;
  
  return {
    contactId: contact.id,
    addedTags,
    suggestions: suggestions.filter(s => !addedTags.includes(s.tag)),
    confidence: avgConfidence
  };
}

/**
 * Bulk auto-tag contacts
 */
export function autoTagContacts(contacts: ContactInfo[]): Map<string, AutoTagResult> {
  const results = new Map<string, AutoTagResult>();
  
  for (const contact of contacts) {
    results.set(contact.id, autoTagContact(contact));
  }
  
  return results;
}

// ==================== TAG MANAGEMENT ====================

/**
 * Create a new tag
 */
export function createTag(
  name: string,
  category: TagCategory,
  color?: string
): Tag {
  const tags = getAllTags();
  
  // Check for duplicate
  if (tags.some(t => t.name.toLowerCase() === name.toLowerCase())) {
    throw new Error(`Tag "${name}" already exists`);
  }
  
  const tag: Tag = {
    id: `tag_${crypto.randomUUID()}`,
    name,
    color: color || generateTagColor(category),
    category,
    autoGenerated: false,
    confidence: 1,
    createdAt: Date.now()
  };
  
  tags.push(tag);
  saveTags(tags);
  
  return tag;
}

/**
 * Delete a tag
 */
export function deleteTag(tagId: string): void {
  const tags = getAllTags();
  saveTags(tags.filter(t => t.id !== tagId));
  
  // Remove from all contacts
  const mapping = JSON.parse(localStorage.getItem(CONTACT_TAGS_KEY) || '{}');
  const tag = tags.find(t => t.id === tagId);
  if (tag) {
    for (const contactId of Object.keys(mapping)) {
      mapping[contactId] = mapping[contactId].filter((t: string) => t !== tag.name);
    }
    localStorage.setItem(CONTACT_TAGS_KEY, JSON.stringify(mapping));
  }
}

/**
 * Get tags by category
 */
export function getTagsByCategory(category: TagCategory): Tag[] {
  return getAllTags().filter(t => t.category === category);
}

/**
 * Get popular tags (most used)
 */
export function getPopularTags(limit: number = 10): { tag: string; count: number }[] {
  try {
    const mapping = JSON.parse(localStorage.getItem(CONTACT_TAGS_KEY) || '{}');
    const tagCounts: Record<string, number> = {};
    
    for (const tags of Object.values(mapping) as string[][]) {
      for (const tag of tags) {
        tagCounts[tag] = (tagCounts[tag] || 0) + 1;
      }
    }
    
    return Object.entries(tagCounts)
      .map(([tag, count]) => ({ tag, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, limit);
  } catch {
    return [];
  }
}

/**
 * Search contacts by tag
 */
export function getContactsByTag(tag: string, contacts: ContactInfo[]): ContactInfo[] {
  try {
    const mapping = JSON.parse(localStorage.getItem(CONTACT_TAGS_KEY) || '{}');
    const matchingIds = Object.entries(mapping)
      .filter(([_, tags]) => (tags as string[]).includes(tag))
      .map(([id]) => id);
    
    return contacts.filter(c => matchingIds.includes(c.id));
  } catch {
    return [];
  }
}

// ==================== UTILITIES ====================

const TAG_COLORS: Record<TagCategory, string> = {
  industry: '#3B82F6', // blue
  role: '#8B5CF6', // purple
  priority: '#EF4444', // red
  status: '#10B981', // green
  source: '#F59E0B', // amber
  custom: '#6B7280', // gray
};

function generateTagColor(category: TagCategory): string {
  return TAG_COLORS[category] || TAG_COLORS.custom;
}

/**
 * Suggest tags based on text input
 */
export function suggestTagsFromText(text: string): string[] {
  const suggestions: string[] = [];
  const lowerText = text.toLowerCase();
  
  // Check industry patterns
  for (const [industry, patterns] of Object.entries(INDUSTRY_PATTERNS)) {
    for (const pattern of patterns) {
      if (pattern.test(lowerText)) {
        suggestions.push(industry);
        break;
      }
    }
  }
  
  // Check role patterns
  for (const [role, patterns] of Object.entries(ROLE_PATTERNS)) {
    for (const pattern of patterns) {
      if (pattern.test(lowerText)) {
        suggestions.push(role);
        break;
      }
    }
  }
  
  return [...new Set(suggestions)];
}
